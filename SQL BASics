# 📌 SQL Server – יסודות חשובים לראיון (עם הסברים בעברית בתוך הקוד)

---

## 1. SELECT + FROM + WHERE
```sql
-- דוגמה בסיסית לשליפה עם סינון:
SELECT game_id, home_team_id, away_team_id, home_score, away_score
FROM games
WHERE date >= '2025-01-01';

-- הסבר:
-- SELECT – אילו עמודות מחזירים
-- FROM – מאיזו טבלה
-- WHERE – אילו שורות לסנן (כאן רק משחקים אחרי 2025-01-01)

-- ב-SQL Server מגבילים תוצאות עם TOP (ולא LIMIT כמו ב-MySQL):
SELECT TOP 5 *
FROM games
ORDER BY date DESC;

-- הסבר:
-- TOP 5 – מחזיר רק 5 שורות
-- ORDER BY date DESC – מסדר לפי תאריך מהאחרון לראשון

-- כמה משחקים שיחקה כל קבוצה:
SELECT team_id, COUNT(*) AS games_played
FROM games_teams
GROUP BY team_id;

-- הסבר:
-- GROUP BY – מאחד שורות לפי ערך (כאן לפי team_id)
-- COUNT(*) – סופר את מספר השורות בכל קבוצה
-- אפשר גם SUM / AVG / MIN / MAX

-- ספירת ניצחונות לכל קבוצה:
SELECT team_id,
       SUM(CASE WHEN result='W' THEN 1 ELSE 0 END) AS wins
FROM games_teams
GROUP BY team_id;

-- הסבר:
-- CASE WHEN – כמו if, בודק תנאי לכל שורה
-- SUM – סוכם את הערכים (1 לניצחון, 0 אחרת)

-- שאילתה שמחזירה שמות קבוצות במקום IDs:
SELECT g.game_id, th.team_name AS home, ta.team_name AS away,
       g.home_score, g.away_score
FROM games g
JOIN teams th ON g.home_team_id = th.team_id
JOIN teams ta ON g.away_team_id = ta.team_id;

-- הסבר:
-- JOIN – מחבר טבלאות לפי תנאי
-- אם לא נגדיר ON נכון → תיווצר כפילות (Cartesian Product)


-- מספר רץ לכל משחק לפי קבוצה:
SELECT game_id, team_id, date,
       ROW_NUMBER() OVER(PARTITION BY team_id ORDER BY date DESC) AS rn
FROM games_teams;

-- הסבר:
-- ROW_NUMBER – נותן מספר לכל שורה
-- PARTITION BY – מתחיל ספירה מחדש לכל קבוצה
-- ORDER BY – מגדיר את סדר המספור
-- שימוש: לבחור את המשחק האחרון לכל קבוצה (WHERE rn=1)


SELECT 
    GETDATE() AS now,                       -- מחזיר את התאריך והשעה הנוכחיים
    DATEADD(DAY, -7, GETDATE()) AS week_ago, -- שבוע אחורה
    DATEDIFF(DAY, date, GETDATE()) AS days_since_game -- הבדל ימים בין המשחק להיום
FROM games;


SELECT 
    LEN(team_name) AS name_length,           -- אורך שם הקבוצה
    CHARINDEX('A', team_name) AS first_A     -- המיקום הראשון של 'A' במחרוזת
FROM teams;


-- רק קבוצות עם יותר מ-5 משחקים:
SELECT team_id, COUNT(*) AS games
FROM games_teams
GROUP BY team_id
HAVING COUNT(*) > 5;

-- הסבר:
-- WHERE – מסנן לפני ה-Group By
-- HAVING – מסנן אחרי ה-Group By (על ערכים מצטברים)

## 10. DISTINCT – להיפטר מכפילויות
```sql
-- מחזיר רשימת קבוצות ייחודיות ששיחקו אי פעם בבית:
SELECT DISTINCT home_team_id
FROM games;

-- הסבר:
-- DISTINCT מסיר כפילויות ברשומות המוחזרות.


-- החלפת ערכי NULL ב-0 כדי למנוע סכומים/ממוצעים שגויים:
SELECT 
  ISNULL(attendance, 0)             AS attendance_isnull, -- SQL Server-ספציפי
  COALESCE(attendance, 0)           AS attendance_coalesce -- סטנדרטי (מועדף לניידות)
FROM games
WHERE attendance IS NULL;           -- בדיקה ל-NULL תמיד עם IS NULL (לא = NULL)


-- מיון לפי תאריך ואז לפי מזהה משחק, והחזרת "עמוד" תוצאות:
SELECT game_id, date, home_team_id, away_team_id
FROM games
ORDER BY date DESC, game_id DESC
OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;   -- דלג 20, הבא 10 (paging בסגנון LIMIT/OFFSET)


-- 3 הסקורים הגבוהים ביותר בבית, כולל "שווי מקום" במקום השלישי:
SELECT TOP (3) WITH TIES game_id, home_score
FROM games
ORDER BY home_score DESC;   -- WITH TIES יחזיר גם שורות נוספות עם אותו דירוג


-- UNION מסיר כפילויות; UNION ALL לא מסיר (מהיר יותר)
SELECT home_team_id AS team_id FROM games
UNION
SELECT away_team_id FROM games;

SELECT home_team_id AS team_id FROM games
UNION ALL
SELECT away_team_id FROM games;


-- המרת תאריך לטקסט ולהיפך:
SELECT 
  CAST(date AS VARCHAR(10))     AS date_text_cast,
  CONVERT(VARCHAR(10), date, 23) AS date_text_convert_yyyy_mm_dd, -- פורמט 23 = YYYY-MM-DD
  CAST('2025-02-01' AS DATE)     AS as_date;


-- משחק אחרון לכל קבוצה (דוגמה קלאסית עם ROW_NUMBER בתוך CTE):
WITH games_expanded AS (
  SELECT 
    game_id, date,
    home_team_id AS team_id, home_score AS gf, away_score AS ga
  FROM games
  UNION ALL
  SELECT 
    game_id, date,
    away_team_id AS team_id, away_score AS gf, home_score AS ga
  FROM games
),
ranked AS (
  SELECT *,
         ROW_NUMBER() OVER(PARTITION BY team_id ORDER BY date DESC, game_id DESC) AS rn
  FROM games_expanded
)
SELECT *
FROM ranked
WHERE rn = 1;  -- השורה האחרונה לכל קבוצה


-- Running total לשערים לכל קבוצה לאורך זמן:
WITH per_team AS (
  SELECT date, home_team_id AS team_id, home_score AS gf FROM games
  UNION ALL
  SELECT date, away_team_id AS team_id, away_score AS gf FROM games
)
SELECT 
  team_id, date, gf,
  SUM(gf) OVER(PARTITION BY team_id ORDER BY date
               ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_gf
FROM per_team;

-- ממוצע נע 3 משחקים:
SELECT 
  team_id, date, gf,
  AVG(gf*1.0) OVER(PARTITION BY team_id ORDER BY date
                   ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS ma3
FROM per_team;


-- דוגמת PIVOT: סכום שערים לפי סוג בית/חוץ לעמודות:
WITH base AS (
  SELECT 'home' AS side, home_score AS goals FROM games
  UNION ALL
  SELECT 'away' AS side, away_score AS goals FROM games
)
SELECT [home] AS home_goals, [away] AS away_goals
FROM base
PIVOT (SUM(goals) FOR side IN ([home], [away])) p;


-- (אין פה קוד רץ – הערות כלליות)
-- 1) אינדקסים: על עמודות שמופיעות ב-JOIN/WHERE/ORDER BY לעיתים כדאי אינדקס.
-- 2) הימנע מפונקציות על העמודה בצד שמאל של WHERE (לדוגמה: WHERE YEAR(date)=2025) – השתמש בטווחי תאריכים.
-- 3) העדף UNION ALL על UNION כשלא צריך הסרת כפילויות – מהיר יותר.
-- 4) EXISTS לרוב יעיל יותר מ-IN על תתי-שאילתה גדולים.
-- 5) בדוק תוכנית ביצוע (Execution Plan) אם שואלים "איך היית מאבחן שאילתה איטית".


